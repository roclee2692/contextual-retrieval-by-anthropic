# 知识图谱 vs 向量检索对比示例

## 🎯 为什么需要知识图谱？

### 场景1：多跳关系查询

**问题**: "一号餐厅有哪些2元的食品？"

#### 向量检索的处理方式
```
1. 将问题向量化
2. 在文档中找相似片段
3. 可能找到：
   - "一号餐厅有19号我爱我粥..."
   - "小米南瓜粥2元一杯..."
4. LLM 尝试从片段中拼凑答案
```

**问题**: 如果"一号餐厅"、"窗口"、"食品"、"价格"分散在不同文档块，检索可能遗漏。

#### 知识图谱的处理方式
```
1. 查询实体"一号餐厅"
2. 遍历关系"包含窗口"
   → [19号我爱我粥, 17号酸辣拌, ...]
3. 遍历关系"提供"
   → [小米南瓜粥, 清火绿豆粥, ...]
4. 过滤关系"价格=2元"
   → [小米南瓜粥, 清火绿豆粥, 紫薯黑米粥, ...]
5. 返回完整列表
```

**优势**: 结构化查询，不会遗漏信息。

---

## 📊 实际对比测试

### 测试问题集

| 问题 | 向量检索 | 知识图谱 | 优势 |
|------|----------|----------|------|
| "龙子湖有几个食堂？" | ⭐⭐⭐ | ⭐⭐⭐⭐ | 图谱能明确列举实体 |
| "哪个食堂最便宜？" | ⭐⭐ | ⭐⭐⭐⭐⭐ | 图谱能做价格聚合比较 |
| "一号餐厅的所有2元食品" | ⭐⭐ | ⭐⭐⭐⭐⭐ | 多跳查询 + 属性过滤 |
| "最便宜的包子在哪？" | ⭐⭐ | ⭐⭐⭐⭐⭐ | 跨实体关联 |
| "食堂环境怎么样？" | ⭐⭐⭐⭐⭐ | ⭐⭐ | 开放性问题，向量更好 |

---

## 🔧 实际使用示例

### 示例 1: 创建知识图谱

```python
# 运行脚本
python create_knowledge_graph.py

# 输出示例：
# ================================================================================
#   龙子湖食堂知识图谱构建
# ================================================================================
# 
# [1/5] 初始化 LLM 和 Embedding...
# ✓ LLM 和 Embedding 初始化完成
# 
# [2/5] 读取 PDF 文档...
# ✓ 加载了 2 个文档
# 
# [3/5] 初始化图存储...
# ✓ 图存储创建完成
# 
# [4/5] 从文档中提取知识图谱...
# ⏱️  预计耗时: 15-40 分钟
# 提取三元组: 100%|████████████████| 63/63 [27:35<00:00, 26.28s/chunk]
# ✓ 知识图谱构建成功
# 
# [5/5] 保存知识图谱...
# ✓ 知识图谱已保存到: ./src/db/knowledge_graph
```

### 示例 2: 测试图谱查询

```python
# 运行测试
python create_knowledge_graph.py test

# 输出示例：
# ================================================================================
# 开始测试查询
# ================================================================================
# 
# 【问题 1】龙子湖校区有几个食堂？
# --------------------------------------------------------------------------------
# 答案:
# 根据提供的信息，龙子湖校区有两个食堂：
# 1. 一号餐厅（一餐）- 包含多个窗口档口
# 2. 二号餐厅（二餐）- 包含多个窗口档口
# --------------------------------------------------------------------------------
# 
# 【问题 2】一号餐厅有哪些窗口？
# --------------------------------------------------------------------------------
# 答案:
# 一号餐厅的窗口包括：
# - 19号窗口：我爱我粥
# - 17号窗口：酸辣拌
# - 22号窗口：闫阿婆掉渣饼
# - 23号窗口：烤盘饭
# ... (共20+个窗口)
# --------------------------------------------------------------------------------
```

### 示例 3: 可视化图谱

```python
# 可视化图谱
python visualize_kg.py

# 输出：
# ================================================================================
#   知识图谱可视化
# ================================================================================
# 
# [1/3] 加载知识图谱...
# ✓ 加载成功
# 
# [2/3] 提取图结构...
# ✓ 节点数: 156
# ✓ 边数: 342
# 
# [3/3] 生成可视化...
# ✓ 图谱已保存到: ./knowledge_graph.png
# 
# 图谱统计
# ================================================================================
# 节点数（实体）: 156
# 边数（关系）: 342
# 
# 前10个节点:
#   1. 一号餐厅
#   2. 二号餐厅
#   3. 我爱我粥
#   4. 小米南瓜粥
#   5. 清火绿豆粥
#   ...
# 
# 前10个关系:
#   1. (一号餐厅) --[包含窗口]--> (19号我爱我粥)
#   2. (我爱我粥) --[提供]--> (小米南瓜粥)
#   3. (小米南瓜粥) --[价格]--> (2元)
#   ...
```

---

## 🎨 知识图谱三元组示例

### 完整的食堂知识结构

```
# 食堂层级
(龙子湖校区, 有食堂, 一号餐厅)
(龙子湖校区, 有食堂, 二号餐厅)

# 餐厅-楼层
(二号餐厅, 有楼层, 一楼)
(二号餐厅, 有楼层, 二楼)

# 楼层-窗口
(一楼, 有窗口, 10号民族风味)
(一楼, 有窗口, 21号天津包子)

# 窗口-档口
(一号餐厅, 有窗口, 19号我爱我粥)
(19号我爱我粥, 窗口号, 19)

# 档口-食品
(我爱我粥, 提供, 小米南瓜粥)
(我爱我粥, 提供, 清火绿豆粥)
(天津包子, 提供, 招牌鲜肉包)

# 食品-属性
(小米南瓜粥, 价格, 2元)
(小米南瓜粥, 单位, 一杯)
(招牌鲜肉包, 价格, 2元)
(招牌鲜肉包, 原价, 2元)

# 特殊属性
(民族风味, 类型, 清真)
(二号餐厅, 楼层数, 2)
```

---

## 🚀 高级查询示例

### 查询 1: 找到最便宜的早餐

```python
query = "一号餐厅有什么便宜的早餐？"

# 知识图谱推理过程：
# 1. 识别实体：一号餐厅
# 2. 筛选：早餐类食品（粥、包子、豆浆...）
# 3. 排序：按价格升序
# 4. 返回：最便宜的选项

# 预期答案：
# 一号餐厅最便宜的早餐选项（2元）：
# - 小米南瓜粥（19号我爱我粥）
# - 清火绿豆粥（19号我爱我粥）
# - 原味豆浆（19号我爱我粥）
# - 现磨豆浆（19号我爱我粥）
```

### 查询 2: 多食堂价格比较

```python
query = "哪个食堂的包子最便宜？"

# 推理过程：
# 1. 识别类别：包子
# 2. 遍历：所有食堂 → 所有窗口 → 所有包子
# 3. 提取价格：
#    - 一号餐厅 → 香港九龙包 → 2元/个
#    - 二号餐厅 → 天津包子 → 1.5元/个（最便宜）
# 4. 比较并返回

# 预期答案：
# 二号餐厅一楼21号窗口的天津包子最便宜，
# 1.5元品类包括：三鲜胡萝卜包、香菇青菜包等。
```

### 查询 3: 实体关联发现

```python
query = "我想吃粥，哪里选择最多？"

# 推理过程：
# 1. 识别类别：粥
# 2. 统计每个食堂/窗口的粥类数量：
#    - 一号餐厅 19号我爱我粥：6种
#    - 一号餐厅 43号好粥道：8种
#    - 二号餐厅 ...
# 3. 排序返回

# 预期答案：
# 一号餐厅43号窗口"好粥道"提供的粥类最多（8种）：
# - 小米南瓜粥、清火绿豆粥、紫薯黑米粥...
```

---

## 🎯 最佳实践：混合检索策略

### 路由器模式（推荐）

```python
from llama_index.core.query_engine import RouterQueryEngine

# 定义查询引擎
vector_engine = vector_index.as_query_engine()  # 向量检索
kg_engine = kg_index.as_query_engine()          # 知识图谱
bm25_engine = bm25_index.as_query_engine()      # 关键词检索

# 创建路由器
router = RouterQueryEngine(
    selector=LLMSingleSelector.from_defaults(llm=llm),
    query_engine_tools=[
        ToolMetadata(
            name="vector",
            description="适用于开放性问题、描述性查询"
        ),
        ToolMetadata(
            name="knowledge_graph",
            description="适用于关系查询、实体查找、多跳推理"
        ),
        ToolMetadata(
            name="bm25",
            description="适用于精确关键词匹配"
        )
    ]
)

# 自动路由
response = router.query("一号餐厅有哪些2元的食品？")
# → 自动选择 knowledge_graph 引擎
```

---

## ⚡ 性能对比

| 指标 | 向量检索 | BM25 | 知识图谱 | 混合检索 |
|------|---------|------|----------|----------|
| **构建时间** | 5-10分钟 | 1-2分钟 | 15-40分钟 | 20-50分钟 |
| **查询速度** | 0.5-2秒 | 0.1-0.5秒 | 1-5秒 | 1-3秒 |
| **准确率（开放性）** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **准确率（实体查找）** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **准确率（多跳推理）** | ⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **存储需求** | 中 | 小 | 大 | 大 |

---

## 💡 建议

### 优先级策略

1. **第一阶段**: 完成向量 + BM25 混合检索
   - 覆盖 80% 的查询场景
   - 构建快，易于调试

2. **第二阶段**: 评估是否需要知识图谱
   - 如果有大量关系查询 → 添加知识图谱
   - 如果主要是描述性问题 → 保持现有方案

3. **第三阶段**: 优化混合策略
   - 实现智能路由
   - 根据问题类型选择最佳引擎

---

**总结**: 知识图谱是强大的工具，但不是所有场景都需要。先完成基础 RAG，再根据实际需求添加图谱能力。

